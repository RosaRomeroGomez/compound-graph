{"version":3,"file":"compound-graph.min.js","sources":["../src/utils/svg-util.js","../src/base.js","../src/utils/removeChildren.js","../src/utils/traverse.js","../src/svg-renderer.js"],"sourcesContent":["import * as d3 from 'd3';\n\n/* SVG Utility functions */\n\n/**\n * Chart wrapper\n * @param {object} svg - D3 svg selection\n * @param {number} w - width\n * @param {number} h - height\n * @param {object} viewport - optional x1, y1, x2, y2.\n */\nexport const createChart = (svg, w, h, viewport = {}) => {\n  svg.attr('width', w + 'px');\n  svg.attr('height', h + 'px');\n\n  const x1 = viewport.x1 || 0;\n  const y1 = viewport.y1 || 0;\n  const x2 = viewport.x2 || w;\n  const y2 = viewport.y2 || h;\n\n  svg.attr('preserveAspectRatio', 'xMinYMin meet');\n  svg.attr('viewBox', `${x1} ${y1} ${x2} ${y2}`);\n  svg.append('defs');\n\n  return svg;\n};\n\nexport const translate = (x, y) => { return `translate(${x}, ${y})`; };\n\nexport const line = (x1, y1, x2, y2) => {\n  return 'M' + x1 + ',' + y1 + 'L' + x2 + ',' + y2;\n};\n\n// A path generator\nexport const pathFn = d3.line()\n  .x(d => d.x)\n  .y(d => d.y);\n\n/**\n * Add style attributes to given d3 selection\n * @param {Object} selection - d3 selection\n * @param {Object} style - A style object\n */\nexport const style = (selection, style = {}) => {\n  for (const [key, value] of Object.entries(style)) {\n    selection.style(key, value);\n  }\n};\n\n// Pre-canned path/glyphs, we assume all paths are bounded by a 10x10 grid and centered at (0, 0)\n// - Arrows point left-to-right\nexport const MARKER_VIEWBOX = '-5 -5 10 10';\nexport const ARROW = 'M 0,-3.25 L 5 ,0 L 0,3.25';\nexport const ARROW_SHARP = 'M 0,-3 L 5 ,0 L 0,3 L 1 0';\n\nexport default {\n  createChart,\n  translate,\n  line,\n  pathFn,\n\n  MARKER_VIEWBOX,\n  ARROW,\n  ARROW_SHARP\n};\n","const registryFunctions = [\n  'backgroundClick',\n  'backgroundDblClick',\n  'backgroundMouseEnter',\n  'backgroundMouseLeave',\n  'backgroundCtx',\n  'nodeClick',\n  'nodeDblClick',\n  'nodeMouseEnter',\n  'nodeMouseLeave',\n  'nodeCtx',\n  'nodeSave',\n  'edgeClick',\n  'edgeMouseEnter',\n  'edgeMouseLeave',\n  'edgeCtx'\n];\n\n/**\n * Specifies an interface/contract for interacting with a graph (node-link)\n */\nexport default class GraphRenderer {\n  constructor() {\n    this.data = {};\n    this.registry = {};\n  }\n\n  setData(data) {\n    this.data = data;\n  }\n\n  setCallback(name, fn) {\n    if (registryFunctions.indexOf(name) === -1) {\n      throw new Error(`Failed to register callback, unknown name ${name}`);\n    } else {\n      this.registry[name] = fn;\n    }\n  }\n\n  unsetCallback(name) {\n    delete this.registry[name];\n  }\n\n  initialize(element) { // eslint-disable-line no-unused-vars\n    throw new Error('Needs impl');\n  }\n\n  render() {\n    throw new Error('Needs impl');\n  }\n};\n","export const removeChildren = (parentElement) => {\n  while (parentElement.firstChild) {\n    parentElement.removeChild(parentElement.firstChild);\n  }\n  return parentElement;\n};\n","/**\n * Recursively traverse a graph that looks like\n * {\n *   nodes: [\n *     {\n *       nodes: [\n *         {\n *           nodes: [ ... ],\n *           edges: [ ... ]\n *         }\n *       ],\n *       edges: [ ... ]\n *     },\n *     ...\n *   ],\n *   edges: [...]\n * }\n */\nexport const traverse = (root, callBackFn, depth = 0) => {\n  callBackFn(root, depth);\n  if (root.nodes) {\n    const d = depth + 1;\n    for (let i = 0; i < root.nodes.length; i++) {\n      traverse(root.nodes[i], callBackFn, d);\n    }\n  }\n};\n\n/**\n * Returns a flat representation of all nodes and edges.\n */\nexport const flatten = (root) => {\n  let nodes = [];\n  let edges = [];\n\n  traverse(root, (node, depth) => {\n    if (depth > 0) {\n      nodes = nodes.concat(node);\n    }\n    if (node.edges) {\n      edges = edges.concat(node.edges);\n    }\n  });\n  return {\n    nodes, edges\n  };\n};\n","import _ from 'lodash';\nimport * as d3 from 'd3';\n\nimport svgUtil from './utils/svg-util';\nimport GraphRenderer from './base';\nimport { flatten, traverse, removeChildren } from './utils';\n\nconst pathFn = svgUtil.pathFn.curve(d3.curveBasis);\n\n/**\n * Just make sure the viewport has a min size so it does not look\n * super large if there are only a few elements\n *\n * @param {object} v - viewport {x2, y2, x2, y2} where x2 y2 are width height respectively\n * @param {object} chartSize - { width, height } the effective size of the chart in pixels\n */\nconst ensureViewportSize = (v, chartSize) => {\n  return {\n    x1: v.x1,\n    y1: v.y1,\n    x2: Math.max(v.x2, chartSize.width),\n    y2: Math.max(v.y2, chartSize.height)\n  };\n};\n\n\n// TODO\n// - Add/Remove without relayout\n// - Edge/node look up performance\n// - Cull edges is buggy\n\n/**\n * Base support for rendering and manipulating a compound/nested graph.\n *\n * 1. It setups a bare-bone rendering skeleton, In the sense that it renders empty group-nodes and move them\n * into their respective layout positions. It is up to the implementation class to provide the actual rendering\n * functions, which are:\n *\n * Basic rendering mode - redraws everything at every render-loop\n * - renderNode\n * - renderEdge\n *\n * Delta rendering mode - redraws added/removed/updated objects\n * - renderNodeAdded\n * - renderNodeUpdated\n * - renderNodeRemoved\n * - renderEdgeAdded\n * - renderEdgeUpdated\n * - renderEdgeRemoved\n *\n * Common/Misc\n * - renderEdgeControl\n *\n * 2. Provides utility functions to navigate and to manipulate the graph object.\n * - Center on a given node with respect to the container\n * - Highlight a set of nodes/edges\n * - Collapse and expand compound nodes\n * - Focus/enlarge leaf nodes\n * - De-clutter/cull-out edges whose source/targets are not in the viewport\n *\n * The input specification consist of two things\n * - Graph data specified as a set of nodes and edges\n * - A configuration object to specify the rendering parameters\n *\n * The renderer itself is layout agnostic, it relies upon and expects a layout adapter to be\n * provided as a part of the configuration object. Moreover it expect the adapter to expose a\n * \"run()\" and \"makeRenderingGraph()\" methods.\n */\nexport default class SVGRenderer extends GraphRenderer {\n  /**\n   * Create Elk graph renderer\n   *\n   * @param {HTMLElement} options.el - A container element that contains the rendered graph\n   * @param {object} options - Renderer options\n   * @param {object} options.adapter - Layout adapter\n   * @param {string} options.renderMode - \"basic\" or \"delta\" modes. The basic mode provides new data-bindings\n   *   every single render loop, where the deta mode provides added/updated/delete objects and allows you to\n   *   handle them separately with different effects.\n   * @param {boolean} options.useEdgeControl - Whether to use edge controls, default to false\n   * @param {string} options.edgeControlOffsetType - \"percentage\" or \"unit\"\n   * @param {numbeer} options.edgeControlOffset - If type is percentage this should be between 0 an 1,\n   *   if unit then a positive value is an offset from the source, and a negative offset from the target.\n   * @param {boolean} options.useDebugger - prints debugging information\n   */\n  constructor(options) {\n    super();\n    this.options = options || {};\n    this.options.renderMode = this.options.renderMode || 'basic';\n    this.options.useEdgeControl = this.options.useEdgeControl || false;\n    this.options.edgeControlOffsetType = this.options.edgeControlOffsetType || 'percentage';\n    this.options.edgeControlOffset = this.options.edgeControlOffset || 0.66;\n    this.options.useDebugger = this.options.useDebugger || false;\n\n    this.adapter = this.options.adapter;\n\n    this.parentEl = null;\n    this.svgEl = null;\n\n    this.chart = null; // D3 chart reference\n    this.chartSize = { width: 1, height: 1 };\n\n    // The graph data + positions\n    this.layout = null;\n\n    if (options.el) {\n      this.initialize(options.el);\n    } else {\n      throw new Error('options must provide an element for graph rendering');\n    }\n\n    // Internal trackers\n    this.zoom = null;\n\n    // Refernece tracker, key nodes' identifiers. This essentially tracks the before-collapse state\n    this.collapseTracker = {};\n    this.hiddenEdges = {};\n  }\n\n  /**\n   * Initialize the renderer with given container element\n   * @param {HTMLElement} element - container element\n   */\n  initialize(element) {\n    this.parentEl = element;\n    this.chartSize.width = this.parentEl.clientWidth;\n    this.chartSize.height = this.parentEl.clientHeight;\n\n    this.svgEl = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n    removeChildren(this.parentEl).appendChild(this.svgEl);\n    this.svgEl.style.userSelect = 'none';\n  }\n\n  /**\n   * Set graph data\n   * @param {Object} data - a graph model data\n   */\n  setData(data) {\n    super.setData(data);\n    this.layout = null; // clear previous layout since it needs to be updated\n  }\n\n\n  /**\n   * Renders the graph\n   */\n  async render() {\n    const options = this.options;\n    if (!this.layout) {\n      this.layout = await this.runLayout();\n    }\n\n    // Addresses the case where swapping layout introduce sufficient changes that\n    // we need to recalculate the viewport dimensions\n    if (!this.chart) {\n      this.chart = this._createChart();\n    } else {\n      const x1 = 0;\n      const y1 = 0;\n      const x2 = this.layout.width;\n      const y2 = this.layout.height;\n      const vp = ensureViewportSize({ x1, y1, x2, y2 }, this.chartSize);\n      d3.select(this.svgEl).attr('viewBox', `${vp.x1} ${vp.y1} ${vp.x2} ${vp.y2}`);\n\n      // Reset zoom\n      const svg = d3.select(this.svgEl);\n      svg.transition().call(\n        this.zoom.transform,\n        d3.zoomIdentity\n      );\n\n      const maxZoom = Math.max(2, Math.floor(this.layout.width / this.chartSize.width));\n      this.zoom.scaleExtent([0.5, maxZoom]);\n    }\n\n    this.buildDefs();\n\n    if (options.renderMode === 'basic') {\n      this.renderNodes();\n      this.renderEdges();\n    } else {\n      this.renderNodesDelta();\n      this.renderEdgesDelta();\n    }\n\n    if (options.useEdgeControl) {\n      this.renderEdgeControls();\n    }\n\n    this._enableDrag();\n    if (options.useDebugger) {\n      this.renderDebug();\n    }\n    this._enableInteraction();\n  }\n\n  // FIXME: Should provide very basic marker definitions and leave the work to the\n  // implementation renderers\n  buildDefs() {\n    const svg = d3.select(this.svgEl);\n    const edges = flatten(this.layout).edges;\n\n    // Clean up\n    svg.select('defs').selectAll('.edge-marker-end').remove();\n\n    svg.select('defs')\n      .selectAll('.edge-marker-end')\n      .data(edges)\n      .enter()\n      .append('marker')\n      .classed('edge-marker-end', true)\n      .attr('id', d => {\n        const source = d.data.source.replace(/\\s/g, '');\n        const target = d.data.target.replace(/\\s/g, '');\n        return `arrowhead-${source}-${target}`;\n      })\n      .attr('viewBox', svgUtil.MARKER_VIEWBOX)\n      .attr('refX', 2)\n      .attr('refY', 0)\n      .attr('orient', 'auto')\n      .attr('markerWidth', 15)\n      .attr('markerHeight', 15)\n      .attr('markerUnits', 'userSpaceOnUse')\n      .attr('xoverflow', 'visible')\n      .append('svg:path')\n      .attr('d', svgUtil.ARROW)\n      .style('fill', '#000')\n      .style('stroke', 'none');\n  }\n\n\n  /**\n   * A fancier version of renderEdges, figure out the delta between\n   * different layout runs and provide access to added, updated, and\n   * removed graph elements.\n   */\n  renderEdgesDelta() {\n    const chart = this.chart;\n    let allEdges = [];\n\n    traverse(this.layout, (node) => {\n      if (node.edges && node.edges.length > 0) {\n        allEdges = allEdges.concat(node.edges);\n      }\n    });\n\n    const edgesGroup = chart.selectAll('.edge').data(allEdges, d => d.id);\n\n    // Scaffold added/updated/removed\n    const newEdges = edgesGroup.enter().append('g').classed('edge', true);\n\n    edgesGroup.exit().each(d => (d.state = 'removed'));\n    newEdges.each(d => (d.state = 'new'));\n    edgesGroup.each(d => (d.state = 'updated'));\n\n    // Rebind because children point to different reference\n    chart.selectAll('.edge').filter(d => d.state === 'updated').each(function(d) {\n      d3.select(this).selectAll('.edge-path').datum(d);\n    });\n\n\n    chart.selectAll('.edge').filter(d => d.state === 'new').call(this.renderEdgeAdded);\n    chart.selectAll('.edge').filter(d => d.state === 'updated').call(this.renderEdgeUpdated);\n    chart.selectAll('.edge').filter(d => d.state === 'removed').call(this.renderEdgeRemoved);\n  }\n\n  renderEdges() {\n    const chart = this.chart;\n    chart.selectAll('.edge').remove();\n\n    const _recursiveBuild = (n) => {\n      if (n.nodes) {\n        n.nodes.forEach(node => {\n          _recursiveBuild(node);\n        });\n      }\n      if (!n.edges) return;\n\n      chart.selectAll('.edge')\n        .data(n.edges, d => d.id)\n        .enter().append('g')\n        .classed('edge', true);\n    };\n    _recursiveBuild(this.layout);\n    chart.selectAll('.edge').call(this.renderEdge);\n  }\n\n\n  /**\n   * A fancier version of renderNodes, figures out the delta between\n   * different layout runs and provide access to added, updated, and\n   * removed graph elements.\n   */\n  renderNodesDelta() {\n    const chart = this.chart;\n\n    const _recursiveBuild = (selection, childrenNodes) => {\n      if (!childrenNodes) return;\n\n      const nodesGroup = selection.selectAll('.node').filter(function() {\n        return this.parentNode === selection.node();\n      }).data(childrenNodes, d => d.id);\n\n      const newNodes = nodesGroup.enter().append('g')\n        .classed('node', true);\n\n      // nodesGroup.exit().remove();\n      nodesGroup.exit().each(d => (d.state = 'removed'));\n      newNodes.each(d => (d.state = 'new'));\n      nodesGroup.each(d => (d.state = 'updated'));\n\n      [newNodes, nodesGroup].forEach(g => {\n        g.each(function(d) {\n          const selection = d3.select(this);\n\n          // Allocate for the node itself\n          if (selection.select('.node-ui').size() === 0) {\n            selection.append('g').classed('node-ui', true);\n          }\n          selection.select('.node-ui').datum(d);\n\n          // Allocate for the node's children\n          if (selection.select('.node-children').size() === 0) {\n            selection.append('g').classed('node-children', true);\n          }\n          _recursiveBuild(selection.select('.node-children'), d.nodes);\n        });\n\n        g.transition().duration(1000).attr('transform', d => {\n          return svgUtil.translate(d.x, d.y);\n        });\n      });\n    };\n    _recursiveBuild(chart, this.layout.nodes);\n\n    chart.selectAll('.node-ui').filter(d => d.state === 'new').call(this.renderNodeAdded);\n    chart.selectAll('.node-ui').filter(d => d.state === 'updated').call(this.renderNodeUpdated);\n    chart.selectAll('.node-ui').filter(d => d.state === 'removed').call(this.renderNodeRemoved);\n  }\n\n  /**\n   * Simple basic renderNodes, just wipe out all nodes and redraw\n   */\n  renderNodes() {\n    const chart = this.chart;\n    chart.selectAll('.node').remove();\n\n    const _recursiveBuild = (selection, childrenNodes) => {\n      if (!childrenNodes) return;\n      const nodesGroup = selection.selectAll('.node')\n        .data(childrenNodes)\n        .enter().append('g')\n        .classed('node', true)\n        .attr('transform', d => {\n          return svgUtil.translate(d.x, d.y);\n        });\n\n      nodesGroup.each(function(d) {\n        const s = d3.select(this);\n        s.append('g').classed('node-ui', true);\n        _recursiveBuild(s.append('g'), d.nodes);\n      });\n    };\n    _recursiveBuild(chart, this.layout.nodes);\n    chart.selectAll('.node-ui').call(this.renderNode);\n  }\n\n  calculateEdgeControlPlacement(pathNode) {\n    const options = this.options;\n    let pos = 0;\n    const total = pathNode.getTotalLength();\n    const offset = options.edgeControlOffset;\n    if (options.edgeControlOffsetType === 'percentage') {\n      pos = offset * total;\n    } else {\n      pos = offset > 0 ? offset : Math.max(0, (total + offset));\n    }\n    const controlPoint = pathNode.getPointAtLength(pos);\n    return controlPoint;\n  }\n\n  /**\n   * Renders a controller UI element along the edge path\n   */\n  renderEdgeControls() {\n    const chart = this.chart;\n    const edges = chart.selectAll('.edge');\n    edges.selectAll('.edge-control').remove();\n\n    const self = this;\n\n    edges.each(function() {\n      const pathNode = d3.select(this).select('path').node();\n      const controlPoint = self.calculateEdgeControlPlacement(pathNode);\n      d3.select(this).append('g')\n        .classed('edge-control', true)\n        .attr('transform', svgUtil.translate(controlPoint.x, controlPoint.y));\n    });\n    chart.selectAll('.edge-control').call(this.renderEdgeControl);\n  }\n\n  /**\n   * Debugging information\n   */\n  renderDebug() {\n    const chart = this.chart;\n    const options = this.options;\n    const chartSize = this.chartSize;\n    const background = d3.select(this.svgEl).select('.background-layer');\n    const width = this.layout.width < chartSize.width ? chartSize.width : this.layout.width;\n    const height = this.layout.height < chartSize.height ? chartSize.height : this.layout.height;\n    const halfW = 0.5 * width;\n    const halfH = 0.5 * height;\n    const gridData = [\n      [-5000, halfH, 5000, halfH],\n      [halfW, -5000, halfW, 5000]\n    ];\n\n    background.selectAll('.info').remove();\n    const info = background.append('g').classed('info', true);\n\n    const t = d3.zoomTransform(chart.node());\n    info.append('text').text('TS: ' + t.k.toFixed(2));\n    info.append('text').text('TX: ' + t.x.toFixed(2));\n    info.append('text').text('TY: ' + t.y.toFixed(2));\n    info.append('text').text('Mode: ' + options.renderMode);\n    info.selectAll('text')\n      .attr('x', 3)\n      .attr('y', (d, i) => (i + 1) * 14)\n      .style('font-size', '10px');\n\n\n    background.selectAll('.grid').remove();\n    background.selectAll('.grid')\n      .data(gridData)\n      .enter()\n      .append('path')\n      .classed('grid', true)\n      .attr('d', d => svgUtil.line(...d))\n      .style('fill', 'none')\n      .style('stroke', '#00F')\n      .style('stroke-width', 1.5)\n      .style('opacity', 0.5);\n  }\n\n  async runLayout() {\n    const renderingGraph = this.adapter.makeRenderingGraph(this.data);\n    const layout = this.adapter.run(renderingGraph);\n    return layout;\n  }\n\n\n  /**\n   * Highlight a subgraph with gaussian blur\n   *\n   * @param {object} options - highlight options\n   * @param {string} options.color - highlight color\n   * @param {number} options.duration - highlight duration\n   */\n  highlight({ nodes, edges }, options) {\n    const svg = d3.select(this.svgEl);\n    const chart = this.chart;\n\n    const color = options.color || 'red';\n    const duration = options.duration || 2000;\n\n    const highlightId = `glow${(new Date()).getTime()}`;\n\n    // Reset\n    // svg.select('#glow').remove();\n\n    // Add temporary filter definition\n    const filter = svg.select('defs')\n      .append('filter')\n      .attr('id', highlightId)\n      .attr('width', '200%')\n      .attr('filterUnits', 'userSpaceOnUse');\n\n    filter.append('feGaussianBlur')\n      .attr('stdDeviation', 4.5)\n      .attr('result', 'blur');\n\n    filter.append('feOffset')\n      .attr('in', 'blur')\n      .attr('result', 'offsetBlur')\n      .attr('dx', 0)\n      .attr('dy', 0)\n      .attr('x', -10)\n      .attr('y', -10);\n\n    filter.append('feFlood')\n      .attr('in', 'offsetBlur')\n      .attr('flood-color', color)\n      .attr('flood-opacity', 0.95)\n      .attr('result', 'offsetColor');\n\n    filter.append('feComposite')\n      .attr('in', 'offsetColor')\n      .attr('in2', 'offsetBlur')\n      .attr('operator', 'in')\n      .attr('result', 'offsetBlur');\n\n\n    const feMerge = filter.append('feMerge');\n    feMerge.append('feMergeNode')\n      .attr('in', 'offsetBlur');\n\n    feMerge.append('feMergeNode')\n      .attr('in', 'SourceGraphic');\n\n\n    // Apply filter\n    // FIXME: not very efficient\n    const hNodes = chart.selectAll('.node').filter(d => { return nodes.includes(d.id); });\n    hNodes.style('filter', `url(#${highlightId})`).classed(`${highlightId}`, true);\n\n    const hEdges = chart.selectAll('.edge').filter(d => { return _.some(edges, edge => edge.source === d.data.source && edge.target === d.data.target); });\n    hEdges.style('filter', `url(#${highlightId})`).classed(`${highlightId}`, true);\n\n    svg.select(`#${highlightId}`).select('feGaussianBlur')\n      .transition()\n      .duration(duration)\n      .attr('stdDeviation', 0)\n      .on('end', () => {\n        hNodes.style('filter', null);\n        hEdges.style('filter', null);\n      });\n\n    return highlightId;\n  }\n\n  unHighlight(id) {\n    const svg = d3.select(this.svgEl);\n    svg.select(`#${id}`).remove();\n    svg.selectAll(`.${id}`).style('filter', null);\n  }\n\n  /**\n   * Centralize provided node in the SVG canvas\n   *\n   * @param {string} nodeId - id\n   * @param {number} duration - animation transition time in millis\n   *\n   * See: https://observablehq.com/@d3/programmatic-zoom\n   */\n  moveTo(nodeId, duration) {\n    const chart = this.chart;\n    const chartSize = this.chartSize;\n    const svg = d3.select(this.svgEl);\n    const width = this.layout.width < chartSize.width ? chartSize.width : this.layout.width;\n    const height = this.layout.height < chartSize.height ? chartSize.height : this.layout.height;\n\n    // t.k = scale, t.x = translateX, t.y = translateY\n    const t = d3.zoomTransform(chart.node());\n\n    const node = flatten(this.layout).nodes.find(n => n.id === nodeId);\n    if (_.isNil(node)) return;\n\n    let globalX = node.x;\n    let globalY = node.y;\n    let temp = node;\n    // while (true) {\n    //   if (_.isNil(temp.parent) || temp.parent.depth === 0) break;\n    while (temp.parent && temp.parent.depth !== 0) {\n      temp = temp.parent;\n      globalX += temp.x;\n      globalY += temp.y;\n      console.log(globalX, globalY);\n    }\n\n    const dx = globalX + 0.5 * node.width;\n    const dy = globalY + 0.5 * node.height;\n    svg.transition().duration(duration).call(\n      this.zoom.transform,\n      d3.zoomIdentity.translate(0, 0).scale(t.k).translate(\n        -dx + (0.5 * width) / t.k,\n        -dy + (0.5 * height) / t.k\n      )\n    );\n  }\n\n  /**\n   * Collapse node and all children nodes.\n   * Note edges whose source and/or target are within the collapsed node are assigned\n   * to the node.\n   *\n   * @param {string} nodeId - node identifier\n   */\n  async collapse(nodeId) {\n    // 1) Grab all nodes\n    const node = this.chart.selectAll('.node').filter(d => d.id === nodeId);\n    const childrenNodeIds = node.selectAll('.node').data().map(d => d.id);\n    const collapseTracker = this.collapseTracker;\n    const hiddenEdges = this.hiddenEdges;\n    collapseTracker[nodeId] = {};\n    collapseTracker[nodeId].edgeMap = {};\n\n    if (childrenNodeIds.length === 0) return; // Don't collapse if already a leaf node\n\n    traverse(this.layout, (node) => {\n      if (node.id === nodeId) {\n        node.width = 40;\n        node.height = 40;\n        collapseTracker[nodeId].nodes = node.nodes;\n\n        // FIXME: This is buggy, if the edges are specified 2 levels or lower it will remove them.\n        // So this means we need to either\n        // - Specify all edges at the top level, or\n        // - Shift the edges to be co-loated with one of their \"new parent\"\n        node.nodes = [];\n        node.collapsed = true;\n      }\n      if (!node.edges) return;\n\n      const hidden = _.remove(node.edges, edge => {\n        return childrenNodeIds.includes(edge.source) && childrenNodeIds.includes(edge.target);\n      });\n      if (!_.isEmpty(hidden)) {\n        hiddenEdges[node.id] = hidden;\n      }\n\n      for (let i = 0; i < node.edges.length; i++) {\n        const edge = node.edges[i];\n        const source = edge.source;\n        const target = edge.target;\n\n        const originalEdge = {};\n        if (childrenNodeIds.includes(source)) {\n          originalEdge.source = edge.source;\n          edge.source = nodeId;\n        }\n        if (childrenNodeIds.includes(target)) {\n          originalEdge.target = edge.target;\n          edge.target = nodeId;\n        }\n\n        if (!_.isEmpty(originalEdge)) {\n          collapseTracker[nodeId].edgeMap[edge.id] = originalEdge;\n        }\n      }\n    });\n    this.layout = await this.adapter.run(this.layout);\n    this.render();\n  }\n\n  /**\n   * Expand a collapsed node, and restore the original states\n   *\n   * @param {string} nodeId - node identifier\n   */\n  async expand(nodeId) {\n    const node = this.chart.selectAll('.node').filter(d => d.id === nodeId);\n    const collapseTracker = this.collapseTracker;\n    const hiddenEdges = this.hiddenEdges;\n    const entry = collapseTracker[nodeId];\n\n    node.datum().nodes = entry.nodes;\n    node.datum().collapsed = false;\n\n    // Restore hidden edges\n    traverse(node.datum(), (n) => {\n      if ({}.hasOwnProperty.call(hiddenEdges, n.id)) {\n        // console.log('restoring for', n.id, n.collapsed);\n        if (n.collapsed === false) {\n          n.edges = n.edges.concat(hiddenEdges[n.id]);\n          delete hiddenEdges[n.id];\n        }\n      }\n    });\n\n    // Revert adjusted edges\n    traverse(this.layout, (node) => {\n      if (!node.edges) return;\n      for (let i = 0; i < node.edges.length; i++) {\n        const edge = node.edges[i];\n        if (entry.edgeMap[edge.id]) {\n          edge.target = entry.edgeMap[edge.id].target || edge.target;\n          edge.source = entry.edgeMap[edge.id].source || edge.source;\n        }\n      }\n    });\n    delete collapseTracker[nodeId];\n\n    this.layout = await this.adapter.run(this.layout);\n    this.render();\n  }\n\n\n  /**\n   * Enlarge node\n   *\n   * @param {string} nodeId\n   */\n  async focus(nodeId) {\n    const prev = this.chart.selectAll('.node').filter(d => d.focused === true);\n    if (prev.size() === 1) {\n      const datum = prev.datum();\n      delete datum.width;\n      delete datum.height;\n      delete datum.focused;\n    }\n\n    const node = this.chart.selectAll('.node').filter(d => d.id === nodeId);\n\n    // Don't enlarge compound nodes\n    if (node.nodes && node.nodes.length > 0) return;\n\n    node.datum().width = 400;\n    node.datum().height = 300;\n    node.datum().focused = true;\n\n    this.layout = await this.adapter.run(this.layout);\n    this.render();\n  }\n\n  async unfocus(nodeId) {\n    const node = this.chart.selectAll('.node').filter(d => d.id === nodeId);\n    const datum = node.datum();\n    delete datum.width;\n    delete datum.height;\n    delete datum.focused;\n    this.layout = await this.adapter.run(this.layout);\n    this.render();\n  }\n\n\n  /**\n   * Group nodes, must be at the same level (all nodes must share the same parent)\n   *\n   * @param {string} groupName\n   * @param {array} nodeIds - node identifiers\n   */\n  async group(groupName, nodeIds) {\n    const chart = this.chart;\n\n    // 0) check parent\n    const nodesData = chart.selectAll('.node').filter(d => nodeIds.includes(d.id)).data();\n    if (_.uniq(nodesData.map(d => d.parent.id)).length !== 1) {\n      console.log('Cannot group across different levels');\n      return;\n    }\n\n    const groupNode = {\n      id: groupName,\n      label: groupName,\n      concept: groupName,\n      depth: nodesData[0].depth,\n      type: 'custom',\n      parent: nodesData[0].parent,\n      nodes: [],\n      data: { label: groupName }\n    };\n\n    // 1) Move nodes to new group\n    const parentData = nodesData[0].parent;\n    nodeIds.forEach(nodeId => {\n      const temp = _.remove(parentData.nodes, node => node.id === nodeId)[0];\n\n      // Need to create a new node wrapper to avoid double pointers problem\n      const newNode = { ...temp };\n      newNode.parent = groupNode;\n      groupNode.nodes.push(newNode);\n    });\n\n    // 2) Add new gruop node\n    parentData.nodes.push(groupNode);\n\n    this.layout = await this.adapter.run(this.layout);\n    this.render();\n  }\n\n  /**\n   * Ungroup\n   * @param {string} groupName\n   */\n  async ungroup(groupName) {\n    const chart = this.chart;\n    const groupData = chart.selectAll('.node').filter(d => d.id === groupName).data()[0];\n    const parentData = groupData.parent;\n\n    // 0) Remove group\n    _.remove(parentData.nodes, n => n.id === groupName);\n\n    // 1) Add group children back into group parent\n    groupData.nodes.forEach(node => {\n      const temp = { ...node };\n      temp.parent = parentData;\n      parentData.nodes.push(temp);\n    });\n    delete groupData.nodes;\n\n    this.layout = await this.adapter.run(this.layout);\n    this.render();\n  }\n\n\n  // See https://github.com/d3/d3-zoom#zoomTransform\n  boundary() {\n    const chart = this.chart;\n    const t = d3.zoomTransform(chart.node());\n    const x1 = (0 - t.x) / t.k;\n    const y1 = (0 - t.y) / t.k;\n    const x2 = (this.layout.width - t.x) / t.k;\n    const y2 = (this.layout.height - t.y) / t.k;\n\n    // const x1 = 0 * t.k + t.x;\n    // const y1 = 0 * t.k + t.y;\n    // const x2 = this.layout.width * t.k + t.x;\n    // const y2 = this.layout.height * t.k + t.y;\n    return { x1, y1, x2, y2 };\n  }\n\n\n  cullEdges() {\n    const { x1, y1, x2, y2 } = this.boundary();\n\n    // Temporarily hide edges\n    this.chart.selectAll('.edge').each(function(d) {\n      const source = _.first(d.points);\n      const target = _.last(d.points);\n\n      if ((source.x < x1 || source.x > x2 || source.y < y1 || source.y > y2) &&\n          (target.x < x1 || target.x > x2 || target.y < y1 || target.y > y2)) {\n        d3.select(this).style('opacity', 0);\n      }\n    });\n  }\n\n  uncullEdges() {\n    d3.selectAll('.edge').style('opacity', 1);\n  }\n\n\n  /**\n   * Prepare the SVG and returns a chart refrence. This function will create three \"layers\": background,\n   * data, and foreground layers. The data-layer corresponds to the chart.\n   */\n  _createChart() {\n    const { width, height } = this.chartSize;\n    const viewPort = {\n      x1: 0,\n      y1: 0,\n      x2: this.layout.width,\n      y2: this.layout.height\n    };\n    const svg = d3.select(this.svgEl);\n    svg.selectAll('*').remove();\n\n    const treatedSVG = svgUtil.createChart(svg, width, height, ensureViewportSize(viewPort, this.chartSize));\n\n    // change to xMinyMin\n    treatedSVG.attr('preserveAspectRatio', 'xMidYMid meet');\n\n    // Add a debugging/background layer\n    treatedSVG.append('g').classed('background-layer', true);\n\n    // Add chart group\n    const chart = treatedSVG.append('g').classed('data-layer', true);\n\n    // Add a foreground layer\n    treatedSVG.append('g').classed('foreground-layer', true);\n\n    const _this = this;\n    function zoomed() {\n      chart.attr('transform', d3.event.transform);\n      if (_this.options.useDebugger) {\n        _this.renderDebug();\n      }\n    }\n\n    const maxZoom = Math.max(2, Math.floor(this.layout.width / this.chartSize.width));\n    this.zoom = d3.zoom().scaleExtent([0.5, maxZoom]).on('zoom', zoomed);\n    svg.call(this.zoom).on('dblclick.zoom', null);\n    return chart;\n  }\n\n  /**\n   * Standard interaction hooks, these are essentially callback functions\n   * that takes in two parameters: A d3 selection of the element, and a\n   * reference to the renderer.\n   */\n  _enableInteraction() {\n    const chart = this.chart;\n    const self = this;\n    const registry = this.registry;\n    const svg = d3.select(this.svgEl);\n    const nodes = chart.selectAll('.node');\n    const edges = chart.selectAll('.edge');\n\n    self.clickTimer = null;\n\n    const registered = (eventName) => {\n      return ({}.hasOwnProperty.call(registry, eventName));\n    };\n\n    svg.on('click', function () {\n      d3.event.stopPropagation();\n      const pointerCoords = d3.zoomTransform(svg.node()).invert(d3.mouse(this));\n      if (registered('backgroundClick')) {\n        registry.backgroundClick(d3.select(this), self, {\n          x: pointerCoords[0],\n          y: pointerCoords[1]\n        });\n      }\n    });\n\n    svg.on('dblclick', function () {\n      d3.event.stopPropagation();\n      const pointerCoords = d3.zoomTransform(svg.node()).invert(d3.mouse(this));\n      if (registered('backgroundDblClick')) {\n        registry.backgroundDblClick(d3.select(this), self, {\n          x: pointerCoords[0],\n          y: pointerCoords[1]\n        });\n      }\n    });\n\n    nodes.on('dblclick', function() {\n      d3.event.stopPropagation();\n      if (registered('nodeDblClick')) {\n        window.clearTimeout(self.clickTimer);\n        registry.nodeDblClick(d3.select(this), self);\n      }\n    });\n\n    nodes.on('click', function() {\n      d3.event.stopPropagation();\n      if (registered('nodeClick')) {\n        const _this = this;\n        window.clearTimeout(self.clickTimer);\n        self.clickTimer = window.setTimeout(() => {\n          registry.nodeClick(d3.select(_this), self);\n        }, 200);\n      }\n    });\n\n    nodes.on('mouseenter', function() {\n      d3.event.stopPropagation();\n      if (registered('nodeMouseEnter')) {\n        registry.nodeMouseEnter(d3.select(this), self);\n      }\n    });\n\n    nodes.on('mouseleave', function() {\n      d3.event.stopPropagation();\n      if (registered('nodeMouseLeave')) {\n        registry.nodeMouseLeave(d3.select(this), self);\n      }\n    });\n\n    edges.on('click', function() {\n      d3.event.stopPropagation();\n      if (registered('edgeClick')) {\n        registry.edgeClick(d3.select(this), self);\n      }\n    });\n\n    edges.on('mouseenter', function() {\n      d3.event.stopPropagation();\n      if (registered('edgeMouseEnter')) {\n        registry.edgeMouseEnter(d3.select(this), self);\n      }\n    });\n\n    edges.on('mouseleave', function() {\n      d3.event.stopPropagation();\n      if (registered('edgeMouseLeave')) {\n        registry.edgeMouseLeave(d3.select(this), self);\n      }\n    });\n  }\n\n  /**\n   * Enable node dragging, this will recalculate edge end points as well\n   */\n  _enableDrag() {\n    const chart = this.chart;\n    const options = this.options;\n    const data = flatten(this.layout);\n    const nodes = chart.selectAll('.node');\n    const self = this;\n\n    function updateEdges() {\n      chart.selectAll('.edge').selectAll('path').attr('d', d => {\n        return pathFn(d.points);\n      });\n      if (options.useEdgeControl) {\n        chart.selectAll('.edge').each(function() {\n          const pathNode = d3.select(this).select('path').node();\n          const controlPoint = self.calculateEdgeControlPlacement(pathNode);\n          d3.select(this).select('.edge-control')\n            .attr('transform', svgUtil.translate(controlPoint.x, controlPoint.y));\n        });\n      }\n    }\n\n    function dragStart() {\n      d3.event.sourceEvent.stopPropagation();\n    }\n\n    function dragMove() {\n      const node = d3.select(this);\n      const draggedIds = [node.datum().id, ...node.selectAll('.node').data().map(d => d.id)];\n\n      // Check if there is a parent container\n      const parentData = d3.select(this.parentNode).datum();\n\n      // Adjust node\n      const dx = d3.event.dx;\n      const dy = d3.event.dy;\n\n      // Short circuit\n      if (parentData) {\n        if (node.datum().x + node.datum().width + dx > (parentData.width) || node.datum().x + dx < 0) {\n          return;\n        }\n        if (node.datum().y + node.datum().height + dy > (parentData.height) || node.datum().y + dy < 0) {\n          return;\n        }\n      }\n\n      node.datum().x += dx;\n      node.datum().y += dy;\n      node.attr('transform', svgUtil.translate(node.datum().x, node.datum().y));\n      // Adjust edge\n      data.edges.forEach(edge => {\n        const source = edge.source;\n        const target = edge.target;\n\n        // FIXME: ids might not work once the graph is actually database driven.\n        if (draggedIds.includes(source) && draggedIds.includes(target)) {\n          edge.points.forEach(p => {\n            p.x += dx;\n            p.y += dy;\n          });\n        } else if (draggedIds.includes(source)) {\n          edge.points[0].x += dx;\n          edge.points[0].y += dy;\n        } else if (draggedIds.includes(target)) {\n          edge.points[edge.points.length - 1].x += dx;\n          edge.points[edge.points.length - 1].y += dy;\n        }\n      });\n\n      // update edges based on new source/target coords\n      updateEdges();\n    }\n\n    function dragEnd() {\n    }\n\n    // FIXME: Need to disable current listeners first before assigning new ones?\n    const nodeDrag = d3.drag()\n      .on('start', dragStart)\n      .on('end', dragEnd)\n      .on('drag', dragMove);\n    nodes.call(nodeDrag);\n  }\n\n  /**\n   * Given a node identifier, trace up the ancestor chain and record edges along the way\n   *\n   * @param {string} id - node identifier\n   */\n  _trace(nodeId) {\n    const checked = {};\n    const data = this.layout || { edges: [] };\n    const tracedEdges = [];\n\n    function backtrack(id) {\n      if ({}.hasOwnProperty.call(checked, id)) return;\n      checked[id] = 1;\n\n      const edges = data.edges.filter(edge => edge.data.target === id);\n      edges.forEach(edge => {\n        tracedEdges.push(edge);\n        backtrack(edge.data.source);\n      });\n    }\n    backtrack(nodeId, [nodeId]);\n\n    return {\n      edges: tracedEdges.map(edge => {\n        return { source: edge.data.source, target: edge.data.target };\n      }),\n      nodes: _.uniq([...tracedEdges.map(e => e.data.source), ...tracedEdges.map(e => e.data.target)])\n    };\n  }\n}\n"],"names":["createChart","svg","w","h","viewport","attr","x1","y1","x2","y2","append","translate","x","y","line","pathFn","d3.line","d","MARKER_VIEWBOX","ARROW","ARROW_SHARP","registryFunctions","traverse","root","callBackFn","depth","nodes","i","length","flatten","edges","node","concat","svgUtil","curve","d3.curveBasis","ensureViewportSize","v","chartSize","Math","max","width","height","[object Object]","this","data","registry","name","fn","indexOf","Error","element","options","super","renderMode","useEdgeControl","edgeControlOffsetType","edgeControlOffset","useDebugger","adapter","parentEl","svgEl","chart","layout","el","initialize","zoom","collapseTracker","hiddenEdges","clientWidth","clientHeight","document","createElementNS","parentElement","firstChild","removeChild","removeChildren","appendChild","style","userSelect","setData","runLayout","vp","d3.select","transition","call","transform","d3.zoomIdentity","maxZoom","floor","scaleExtent","_createChart","buildDefs","renderNodes","renderEdges","renderNodesDelta","renderEdgesDelta","renderEdgeControls","_enableDrag","renderDebug","_enableInteraction","select","selectAll","remove","enter","classed","source","replace","target","allEdges","edgesGroup","id","newEdges","exit","each","state","filter","datum","renderEdgeAdded","renderEdgeUpdated","renderEdgeRemoved","_recursiveBuild","n","forEach","renderEdge","selection","childrenNodes","nodesGroup","parentNode","newNodes","g","size","duration","renderNodeAdded","renderNodeUpdated","renderNodeRemoved","s","renderNode","pathNode","pos","total","getTotalLength","offset","getPointAtLength","self","controlPoint","calculateEdgeControlPlacement","renderEdgeControl","background","halfW","halfH","gridData","info","t","d3.zoomTransform","text","k","toFixed","renderingGraph","makeRenderingGraph","run","color","highlightId","Date","getTime","feMerge","hNodes","includes","hEdges","_","some","edge","on","nodeId","find","isNil","globalX","globalY","temp","parent","console","log","dx","dy","scale","childrenNodeIds","map","edgeMap","collapsed","hidden","isEmpty","originalEdge","render","entry","hasOwnProperty","prev","focused","groupName","nodeIds","nodesData","uniq","groupNode","label","concept","type","parentData","newNode","push","groupData","boundary","first","points","last","d3.selectAll","viewPort","treatedSVG","_this","d3.zoom","d3.event","clickTimer","registered","eventName","stopPropagation","pointerCoords","invert","d3.mouse","backgroundClick","backgroundDblClick","window","clearTimeout","nodeDblClick","setTimeout","nodeClick","nodeMouseEnter","nodeMouseLeave","edgeClick","edgeMouseEnter","edgeMouseLeave","nodeDrag","d3.drag","sourceEvent","draggedIds","p","checked","tracedEdges","backtrack","e"],"mappings":"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"}