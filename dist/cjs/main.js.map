{"version":3,"file":"main.js","sources":["../../src/utils/svg-util.js","../../src/base.js","../../src/utils/traverse.js","../../src/svg-renderer.js","../../src/utils/removeChildren.js"],"sourcesContent":["import * as d3 from 'd3';\n\n/* SVG Utility functions */\n\n/**\n * Chart wrapper\n * @param {object} svg - D3 svg selection\n * @param {number} w - width\n * @param {number} h - height\n * @param {object} viewport - optional x1, y1, x2, y2.\n */\nexport const createChart = (svg, w, h, viewport = {}) => {\n  svg.attr('width', w + 'px');\n  svg.attr('height', h + 'px');\n\n  const x1 = viewport.x1 || 0;\n  const y1 = viewport.y1 || 0;\n  const x2 = viewport.x2 || w;\n  const y2 = viewport.y2 || h;\n\n  svg.attr('preserveAspectRatio', 'xMinYMin meet');\n  svg.attr('viewBox', `${x1} ${y1} ${x2} ${y2}`);\n  svg.append('defs');\n\n  return svg;\n};\n\nexport const translate = (x, y) => { return `translate(${x}, ${y})`; };\n\nexport const line = (x1, y1, x2, y2) => {\n  return 'M' + x1 + ',' + y1 + 'L' + x2 + ',' + y2;\n};\n\n// A path generator\nexport const pathFn = d3.line()\n  .x(d => d.x)\n  .y(d => d.y);\n\n/**\n * Add style attributes to given d3 selection\n * @param {Object} selection - d3 selection\n * @param {Object} style - A style object\n */\nexport const style = (selection, style = {}) => {\n  for (const [key, value] of Object.entries(style)) {\n    selection.style(key, value);\n  }\n};\n\n// Pre-canned path/glyphs, we assume all paths are bounded by a 10x10 grid and centered at (0, 0)\n// - Arrows point left-to-right\nexport const MARKER_VIEWBOX = '-5 -5 10 10';\nexport const ARROW = 'M 0,-3.25 L 5 ,0 L 0,3.25';\nexport const ARROW_SHARP = 'M 0,-3 L 5 ,0 L 0,3 L 1 0';\n\nexport default {\n  createChart,\n  translate,\n  line,\n  pathFn,\n\n  MARKER_VIEWBOX,\n  ARROW,\n  ARROW_SHARP\n};\n","const registryFunctions = [\n  'backgroundClick',\n  'backgroundDblClick',\n  'backgroundMouseEnter',\n  'backgroundMouseLeave',\n  'backgroundCtx',\n  'nodeClick',\n  'nodeDblClick',\n  'nodeMouseEnter',\n  'nodeMouseLeave',\n  'nodeCtx',\n  'nodeSave',\n  'edgeClick',\n  'edgeMouseEnter',\n  'edgeMouseLeave',\n  'edgeCtx'\n];\n\n/**\n * Specifies an interface/contract for interacting with a graph (node-link)\n */\nexport default class GraphRenderer {\n  constructor() {\n    this.data = {};\n    this.registry = {};\n  }\n\n  setData(data) {\n    this.data = data;\n  }\n\n  setCallback(name, fn) {\n    if (registryFunctions.indexOf(name) === -1) {\n      throw new Error(`Failed to register callback, unknown name ${name}`);\n    } else {\n      this.registry[name] = fn;\n    }\n  }\n\n  unsetCallback(name) {\n    delete this.registry[name];\n  }\n\n  initialize(element) { // eslint-disable-line no-unused-vars\n    throw new Error('Needs impl');\n  }\n\n  render() {\n    throw new Error('Needs impl');\n  }\n};\n","/**\n * Recursively traverse a graph that looks like\n * {\n *   nodes: [\n *     {\n *       nodes: [\n *         {\n *           nodes: [ ... ],\n *           edges: [ ... ]\n *         }\n *       ],\n *       edges: [ ... ]\n *     },\n *     ...\n *   ],\n *   edges: [...]\n * }\n */\nexport const traverse = (root, callBackFn, depth = 0) => {\n  callBackFn(root, depth);\n  if (root.nodes) {\n    const d = depth + 1;\n    for (let i = 0; i < root.nodes.length; i++) {\n      traverse(root.nodes[i], callBackFn, d);\n    }\n  }\n};\n\n/**\n * Returns a flat representation of all nodes and edges.\n */\nexport const flatten = (root) => {\n  let nodes = [];\n  let edges = [];\n\n  traverse(root, (node, depth) => {\n    if (depth > 0) {\n      nodes = nodes.concat(node);\n    }\n    if (node.edges) {\n      edges = edges.concat(node.edges);\n    }\n  });\n  return {\n    nodes, edges\n  };\n};\n","import _ from 'lodash';\nimport * as d3 from 'd3';\n\nimport svgUtil from './utils/svg-util';\nimport GraphRenderer from './base';\nimport { flatten, traverse, removeChildren } from './utils';\n\nconst pathFn = svgUtil.pathFn.curve(d3.curveBasis);\n\n/**\n * Just make sure the viewport has a min size so it does not look\n * super large if there are only a few elements\n *\n * @param {object} v - viewport {x2, y2, x2, y2} where x2 y2 are width height respectively\n * @param {object} chartSize - { width, height } the effective size of the chart in pixels\n */\nconst ensureViewportSize = (v, chartSize) => {\n  return {\n    x1: v.x1,\n    y1: v.y1,\n    x2: Math.max(v.x2, chartSize.width),\n    y2: Math.max(v.y2, chartSize.height)\n  };\n};\n\n\n// TODO\n// - Add/Remove without relayout\n// - Edge/node look up performance\n// - Cull edges is buggy\n\n/**\n * Base support for rendering and manipulating a compound/nested graph.\n *\n * 1. It setups a bare-bone rendering skeleton, In the sense that it renders empty group-nodes and move them\n * into their respective layout positions. It is up to the implementation class to provide the actual rendering\n * functions, which are:\n *\n * Basic rendering mode - redraws everything at every render-loop\n * - renderNode\n * - renderEdge\n *\n * Delta rendering mode - redraws added/removed/updated objects\n * - renderNodeAdded\n * - renderNodeUpdated\n * - renderNodeRemoved\n * - renderEdgeAdded\n * - renderEdgeUpdated\n * - renderEdgeRemoved\n *\n * Common/Misc\n * - renderEdgeControl\n *\n * 2. Provides utility functions to navigate and to manipulate the graph object.\n * - Center on a given node with respect to the container\n * - Highlight a set of nodes/edges\n * - Collapse and expand compound nodes\n * - Focus/enlarge leaf nodes\n * - De-clutter/cull-out edges whose source/targets are not in the viewport\n *\n * The input specification consist of two things\n * - Graph data specified as a set of nodes and edges\n * - A configuration object to specify the rendering parameters\n *\n * The renderer itself is layout agnostic, it relies upon and expects a layout adapter to be\n * provided as a part of the configuration object. Moreover it expect the adapter to expose a\n * \"run()\" and \"makeRenderingGraph()\" methods.\n */\nexport default class SVGRenderer extends GraphRenderer {\n  /**\n   * Create Elk graph renderer\n   *\n   * @param {HTMLElement} options.el - A container element that contains the rendered graph\n   * @param {object} options - Renderer options\n   * @param {object} options.adapter - Layout adapter\n   * @param {string} options.renderMode - \"basic\" or \"delta\" modes. The basic mode provides new data-bindings\n   *   every single render loop, where the deta mode provides added/updated/delete objects and allows you to\n   *   handle them separately with different effects.\n   * @param {boolean} options.useEdgeControl - Whether to use edge controls, default to false\n   * @param {string} options.edgeControlOffsetType - \"percentage\" or \"unit\"\n   * @param {numbeer} options.edgeControlOffset - If type is percentage this should be between 0 an 1,\n   *   if unit then a positive value is an offset from the source, and a negative offset from the target.\n   * @param {boolean} options.useDebugger - prints debugging information\n   */\n  constructor(options) {\n    super();\n    this.options = options || {};\n    this.options.renderMode = this.options.renderMode || 'basic';\n    this.options.useEdgeControl = this.options.useEdgeControl || false;\n    this.options.edgeControlOffsetType = this.options.edgeControlOffsetType || 'percentage';\n    this.options.edgeControlOffset = this.options.edgeControlOffset || 0.66;\n    this.options.useDebugger = this.options.useDebugger || false;\n\n    this.adapter = this.options.adapter;\n\n    this.parentEl = null;\n    this.svgEl = null;\n\n    this.chart = null; // D3 chart reference\n    this.chartSize = { width: 1, height: 1 };\n\n    // The graph data + positions\n    this.layout = null;\n\n    if (options.el) {\n      this.initialize(options.el);\n    } else {\n      throw new Error('options must provide an element for graph rendering');\n    }\n\n    // Internal trackers\n    this.zoom = null;\n\n    // Refernece tracker, key nodes' identifiers. This essentially tracks the before-collapse state\n    this.collapseTracker = {};\n    this.hiddenEdges = {};\n  }\n\n  /**\n   * Initialize the renderer with given container element\n   * @param {HTMLElement} element - container element\n   */\n  initialize(element) {\n    this.parentEl = element;\n    this.chartSize.width = this.parentEl.clientWidth;\n    this.chartSize.height = this.parentEl.clientHeight;\n\n    this.svgEl = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n    removeChildren(this.parentEl).appendChild(this.svgEl);\n    this.svgEl.style.userSelect = 'none';\n  }\n\n  /**\n   * Set graph data\n   * @param {Object} data - a graph model data\n   */\n  setData(data) {\n    super.setData(data);\n    this.layout = null; // clear previous layout since it needs to be updated\n  }\n\n\n  /**\n   * Renders the graph\n   */\n  async render() {\n    const options = this.options;\n    if (!this.layout) {\n      this.layout = await this.runLayout();\n    }\n\n    // Addresses the case where swapping layout introduce sufficient changes that\n    // we need to recalculate the viewport dimensions\n    if (!this.chart) {\n      this.chart = this._createChart();\n    } else {\n      const x1 = 0;\n      const y1 = 0;\n      const x2 = this.layout.width;\n      const y2 = this.layout.height;\n      const vp = ensureViewportSize({ x1, y1, x2, y2 }, this.chartSize);\n      d3.select(this.svgEl).attr('viewBox', `${vp.x1} ${vp.y1} ${vp.x2} ${vp.y2}`);\n\n      // Reset zoom\n      const svg = d3.select(this.svgEl);\n      svg.transition().call(\n        this.zoom.transform,\n        d3.zoomIdentity\n      );\n\n      const maxZoom = Math.max(2, Math.floor(this.layout.width / this.chartSize.width));\n      this.zoom.scaleExtent([0.5, maxZoom]);\n    }\n\n    this.buildDefs();\n\n    if (options.renderMode === 'basic') {\n      this.renderNodes();\n      this.renderEdges();\n    } else {\n      this.renderNodesDelta();\n      this.renderEdgesDelta();\n    }\n\n    if (options.useEdgeControl) {\n      this.renderEdgeControls();\n    }\n\n    this._enableDrag();\n    if (options.useDebugger) {\n      this.renderDebug();\n    }\n    this._enableInteraction();\n  }\n\n  // FIXME: Should provide very basic marker definitions and leave the work to the\n  // implementation renderers\n  buildDefs() {\n    const svg = d3.select(this.svgEl);\n    const edges = flatten(this.layout).edges;\n\n    // Clean up\n    svg.select('defs').selectAll('.edge-marker-end').remove();\n\n    svg.select('defs')\n      .selectAll('.edge-marker-end')\n      .data(edges)\n      .enter()\n      .append('marker')\n      .classed('edge-marker-end', true)\n      .attr('id', d => {\n        const source = d.data.source.replace(/\\s/g, '');\n        const target = d.data.target.replace(/\\s/g, '');\n        return `arrowhead-${source}-${target}`;\n      })\n      .attr('viewBox', svgUtil.MARKER_VIEWBOX)\n      .attr('refX', 2)\n      .attr('refY', 0)\n      .attr('orient', 'auto')\n      .attr('markerWidth', 15)\n      .attr('markerHeight', 15)\n      .attr('markerUnits', 'userSpaceOnUse')\n      .attr('xoverflow', 'visible')\n      .append('svg:path')\n      .attr('d', svgUtil.ARROW)\n      .style('fill', '#000')\n      .style('stroke', 'none');\n  }\n\n\n  /**\n   * A fancier version of renderEdges, figure out the delta between\n   * different layout runs and provide access to added, updated, and\n   * removed graph elements.\n   */\n  renderEdgesDelta() {\n    const chart = this.chart;\n    let allEdges = [];\n\n    traverse(this.layout, (node) => {\n      if (node.edges && node.edges.length > 0) {\n        allEdges = allEdges.concat(node.edges);\n      }\n    });\n\n    const edgesGroup = chart.selectAll('.edge').data(allEdges, d => d.id);\n\n    // Scaffold added/updated/removed\n    const newEdges = edgesGroup.enter().append('g').classed('edge', true);\n\n    edgesGroup.exit().each(d => (d.state = 'removed'));\n    newEdges.each(d => (d.state = 'new'));\n    edgesGroup.each(d => (d.state = 'updated'));\n\n    // Rebind because children point to different reference\n    chart.selectAll('.edge').filter(d => d.state === 'updated').each(function(d) {\n      d3.select(this).selectAll('.edge-path').datum(d);\n    });\n\n\n    chart.selectAll('.edge').filter(d => d.state === 'new').call(this.renderEdgeAdded);\n    chart.selectAll('.edge').filter(d => d.state === 'updated').call(this.renderEdgeUpdated);\n    chart.selectAll('.edge').filter(d => d.state === 'removed').call(this.renderEdgeRemoved);\n  }\n\n  renderEdges() {\n    const chart = this.chart;\n    chart.selectAll('.edge').remove();\n\n    const _recursiveBuild = (n) => {\n      if (n.nodes) {\n        n.nodes.forEach(node => {\n          _recursiveBuild(node);\n        });\n      }\n      if (!n.edges) return;\n\n      chart.selectAll('.edge')\n        .data(n.edges, d => d.id)\n        .enter().append('g')\n        .classed('edge', true);\n    };\n    _recursiveBuild(this.layout);\n    chart.selectAll('.edge').call(this.renderEdge);\n  }\n\n\n  /**\n   * A fancier version of renderNodes, figures out the delta between\n   * different layout runs and provide access to added, updated, and\n   * removed graph elements.\n   */\n  renderNodesDelta() {\n    const chart = this.chart;\n\n    const _recursiveBuild = (selection, childrenNodes) => {\n      if (!childrenNodes) return;\n\n      const nodesGroup = selection.selectAll('.node').filter(function() {\n        return this.parentNode === selection.node();\n      }).data(childrenNodes, d => d.id);\n\n      const newNodes = nodesGroup.enter().append('g')\n        .classed('node', true);\n\n      // nodesGroup.exit().remove();\n      nodesGroup.exit().each(d => (d.state = 'removed'));\n      newNodes.each(d => (d.state = 'new'));\n      nodesGroup.each(d => (d.state = 'updated'));\n\n      [newNodes, nodesGroup].forEach(g => {\n        g.each(function(d) {\n          const selection = d3.select(this);\n\n          // Allocate for the node itself\n          if (selection.select('.node-ui').size() === 0) {\n            selection.append('g').classed('node-ui', true);\n          }\n          selection.select('.node-ui').datum(d);\n\n          // Allocate for the node's children\n          if (selection.select('.node-children').size() === 0) {\n            selection.append('g').classed('node-children', true);\n          }\n          _recursiveBuild(selection.select('.node-children'), d.nodes);\n        });\n\n        g.transition().duration(1000).attr('transform', d => {\n          return svgUtil.translate(d.x, d.y);\n        });\n      });\n    };\n    _recursiveBuild(chart, this.layout.nodes);\n\n    chart.selectAll('.node-ui').filter(d => d.state === 'new').call(this.renderNodeAdded);\n    chart.selectAll('.node-ui').filter(d => d.state === 'updated').call(this.renderNodeUpdated);\n    chart.selectAll('.node-ui').filter(d => d.state === 'removed').call(this.renderNodeRemoved);\n  }\n\n  /**\n   * Simple basic renderNodes, just wipe out all nodes and redraw\n   */\n  renderNodes() {\n    const chart = this.chart;\n    chart.selectAll('.node').remove();\n\n    const _recursiveBuild = (selection, childrenNodes) => {\n      if (!childrenNodes) return;\n      const nodesGroup = selection.selectAll('.node')\n        .data(childrenNodes)\n        .enter().append('g')\n        .classed('node', true)\n        .attr('transform', d => {\n          return svgUtil.translate(d.x, d.y);\n        });\n\n      nodesGroup.each(function(d) {\n        const s = d3.select(this);\n        s.append('g').classed('node-ui', true);\n        _recursiveBuild(s.append('g'), d.nodes);\n      });\n    };\n    _recursiveBuild(chart, this.layout.nodes);\n    chart.selectAll('.node-ui').call(this.renderNode);\n  }\n\n  calculateEdgeControlPlacement(pathNode) {\n    const options = this.options;\n    let pos = 0;\n    const total = pathNode.getTotalLength();\n    const offset = options.edgeControlOffset;\n    if (options.edgeControlOffsetType === 'percentage') {\n      pos = offset * total;\n    } else {\n      pos = offset > 0 ? offset : Math.max(0, (total + offset));\n    }\n    const controlPoint = pathNode.getPointAtLength(pos);\n    return controlPoint;\n  }\n\n  /**\n   * Renders a controller UI element along the edge path\n   */\n  renderEdgeControls() {\n    const chart = this.chart;\n    const edges = chart.selectAll('.edge');\n    edges.selectAll('.edge-control').remove();\n\n    const self = this;\n\n    edges.each(function() {\n      const pathNode = d3.select(this).select('path').node();\n      const controlPoint = self.calculateEdgeControlPlacement(pathNode);\n      d3.select(this).append('g')\n        .classed('edge-control', true)\n        .attr('transform', svgUtil.translate(controlPoint.x, controlPoint.y));\n    });\n    chart.selectAll('.edge-control').call(this.renderEdgeControl);\n  }\n\n  /**\n   * Debugging information\n   */\n  renderDebug() {\n    const chart = this.chart;\n    const options = this.options;\n    const chartSize = this.chartSize;\n    const background = d3.select(this.svgEl).select('.background-layer');\n    const width = this.layout.width < chartSize.width ? chartSize.width : this.layout.width;\n    const height = this.layout.height < chartSize.height ? chartSize.height : this.layout.height;\n    const halfW = 0.5 * width;\n    const halfH = 0.5 * height;\n    const gridData = [\n      [-5000, halfH, 5000, halfH],\n      [halfW, -5000, halfW, 5000]\n    ];\n\n    background.selectAll('.info').remove();\n    const info = background.append('g').classed('info', true);\n\n    const t = d3.zoomTransform(chart.node());\n    info.append('text').text('TS: ' + t.k.toFixed(2));\n    info.append('text').text('TX: ' + t.x.toFixed(2));\n    info.append('text').text('TY: ' + t.y.toFixed(2));\n    info.append('text').text('Mode: ' + options.renderMode);\n    info.selectAll('text')\n      .attr('x', 3)\n      .attr('y', (d, i) => (i + 1) * 14)\n      .style('font-size', '10px');\n\n\n    background.selectAll('.grid').remove();\n    background.selectAll('.grid')\n      .data(gridData)\n      .enter()\n      .append('path')\n      .classed('grid', true)\n      .attr('d', d => svgUtil.line(...d))\n      .style('fill', 'none')\n      .style('stroke', '#00F')\n      .style('stroke-width', 1.5)\n      .style('opacity', 0.5);\n  }\n\n  async runLayout() {\n    const renderingGraph = this.adapter.makeRenderingGraph(this.data);\n    const layout = this.adapter.run(renderingGraph);\n    return layout;\n  }\n\n\n  /**\n   * Highlight a subgraph with gaussian blur\n   *\n   * @param {object} options - highlight options\n   * @param {string} options.color - highlight color\n   * @param {number} options.duration - highlight duration\n   */\n  highlight({ nodes, edges }, options) {\n    const svg = d3.select(this.svgEl);\n    const chart = this.chart;\n\n    const color = options.color || 'red';\n    const duration = options.duration || 2000;\n\n    const highlightId = `glow${(new Date()).getTime()}`;\n\n    // Reset\n    // svg.select('#glow').remove();\n\n    // Add temporary filter definition\n    const filter = svg.select('defs')\n      .append('filter')\n      .attr('id', highlightId)\n      .attr('width', '200%')\n      .attr('filterUnits', 'userSpaceOnUse');\n\n    filter.append('feGaussianBlur')\n      .attr('stdDeviation', 4.5)\n      .attr('result', 'blur');\n\n    filter.append('feOffset')\n      .attr('in', 'blur')\n      .attr('result', 'offsetBlur')\n      .attr('dx', 0)\n      .attr('dy', 0)\n      .attr('x', -10)\n      .attr('y', -10);\n\n    filter.append('feFlood')\n      .attr('in', 'offsetBlur')\n      .attr('flood-color', color)\n      .attr('flood-opacity', 0.95)\n      .attr('result', 'offsetColor');\n\n    filter.append('feComposite')\n      .attr('in', 'offsetColor')\n      .attr('in2', 'offsetBlur')\n      .attr('operator', 'in')\n      .attr('result', 'offsetBlur');\n\n\n    const feMerge = filter.append('feMerge');\n    feMerge.append('feMergeNode')\n      .attr('in', 'offsetBlur');\n\n    feMerge.append('feMergeNode')\n      .attr('in', 'SourceGraphic');\n\n\n    // Apply filter\n    // FIXME: not very efficient\n    const hNodes = chart.selectAll('.node').filter(d => { return nodes.includes(d.id); });\n    hNodes.style('filter', `url(#${highlightId})`).classed(`${highlightId}`, true);\n\n    const hEdges = chart.selectAll('.edge').filter(d => { return _.some(edges, edge => edge.source === d.data.source && edge.target === d.data.target); });\n    hEdges.style('filter', `url(#${highlightId})`).classed(`${highlightId}`, true);\n\n    svg.select(`#${highlightId}`).select('feGaussianBlur')\n      .transition()\n      .duration(duration)\n      .attr('stdDeviation', 0)\n      .on('end', () => {\n        hNodes.style('filter', null);\n        hEdges.style('filter', null);\n      });\n\n    return highlightId;\n  }\n\n  unHighlight(id) {\n    const svg = d3.select(this.svgEl);\n    svg.select(`#${id}`).remove();\n    svg.selectAll(`.${id}`).style('filter', null);\n  }\n\n  /**\n   * Centralize provided node in the SVG canvas\n   *\n   * @param {string} nodeId - id\n   * @param {number} duration - animation transition time in millis\n   *\n   * See: https://observablehq.com/@d3/programmatic-zoom\n   */\n  moveTo(nodeId, duration) {\n    const chart = this.chart;\n    const chartSize = this.chartSize;\n    const svg = d3.select(this.svgEl);\n    const width = this.layout.width < chartSize.width ? chartSize.width : this.layout.width;\n    const height = this.layout.height < chartSize.height ? chartSize.height : this.layout.height;\n\n    // t.k = scale, t.x = translateX, t.y = translateY\n    const t = d3.zoomTransform(chart.node());\n\n    const node = flatten(this.layout).nodes.find(n => n.id === nodeId);\n    if (_.isNil(node)) return;\n\n    let globalX = node.x;\n    let globalY = node.y;\n    let temp = node;\n    // while (true) {\n    //   if (_.isNil(temp.parent) || temp.parent.depth === 0) break;\n    while (temp.parent && temp.parent.depth !== 0) {\n      temp = temp.parent;\n      globalX += temp.x;\n      globalY += temp.y;\n      console.log(globalX, globalY);\n    }\n\n    const dx = globalX + 0.5 * node.width;\n    const dy = globalY + 0.5 * node.height;\n    svg.transition().duration(duration).call(\n      this.zoom.transform,\n      d3.zoomIdentity.translate(0, 0).scale(t.k).translate(\n        -dx + (0.5 * width) / t.k,\n        -dy + (0.5 * height) / t.k\n      )\n    );\n  }\n\n  /**\n   * Collapse node and all children nodes.\n   * Note edges whose source and/or target are within the collapsed node are assigned\n   * to the node.\n   *\n   * @param {string} nodeId - node identifier\n   */\n  async collapse(nodeId) {\n    // 1) Grab all nodes\n    const node = this.chart.selectAll('.node').filter(d => d.id === nodeId);\n    const childrenNodeIds = node.selectAll('.node').data().map(d => d.id);\n    const collapseTracker = this.collapseTracker;\n    const hiddenEdges = this.hiddenEdges;\n    collapseTracker[nodeId] = {};\n    collapseTracker[nodeId].edgeMap = {};\n\n    if (childrenNodeIds.length === 0) return; // Don't collapse if already a leaf node\n\n    traverse(this.layout, (node) => {\n      if (node.id === nodeId) {\n        node.width = 40;\n        node.height = 40;\n        collapseTracker[nodeId].nodes = node.nodes;\n\n        // FIXME: This is buggy, if the edges are specified 2 levels or lower it will remove them.\n        // So this means we need to either\n        // - Specify all edges at the top level, or\n        // - Shift the edges to be co-loated with one of their \"new parent\"\n        node.nodes = [];\n        node.collapsed = true;\n      }\n      if (!node.edges) return;\n\n      const hidden = _.remove(node.edges, edge => {\n        return childrenNodeIds.includes(edge.source) && childrenNodeIds.includes(edge.target);\n      });\n      if (!_.isEmpty(hidden)) {\n        hiddenEdges[node.id] = hidden;\n      }\n\n      for (let i = 0; i < node.edges.length; i++) {\n        const edge = node.edges[i];\n        const source = edge.source;\n        const target = edge.target;\n\n        const originalEdge = {};\n        if (childrenNodeIds.includes(source)) {\n          originalEdge.source = edge.source;\n          edge.source = nodeId;\n        }\n        if (childrenNodeIds.includes(target)) {\n          originalEdge.target = edge.target;\n          edge.target = nodeId;\n        }\n\n        if (!_.isEmpty(originalEdge)) {\n          collapseTracker[nodeId].edgeMap[edge.id] = originalEdge;\n        }\n      }\n    });\n    this.layout = await this.adapter.run(this.layout);\n    this.render();\n  }\n\n  /**\n   * Expand a collapsed node, and restore the original states\n   *\n   * @param {string} nodeId - node identifier\n   */\n  async expand(nodeId) {\n    const node = this.chart.selectAll('.node').filter(d => d.id === nodeId);\n    const collapseTracker = this.collapseTracker;\n    const hiddenEdges = this.hiddenEdges;\n    const entry = collapseTracker[nodeId];\n\n    node.datum().nodes = entry.nodes;\n    node.datum().collapsed = false;\n\n    // Restore hidden edges\n    traverse(node.datum(), (n) => {\n      if ({}.hasOwnProperty.call(hiddenEdges, n.id)) {\n        // console.log('restoring for', n.id, n.collapsed);\n        if (n.collapsed === false) {\n          n.edges = n.edges.concat(hiddenEdges[n.id]);\n          delete hiddenEdges[n.id];\n        }\n      }\n    });\n\n    // Revert adjusted edges\n    traverse(this.layout, (node) => {\n      if (!node.edges) return;\n      for (let i = 0; i < node.edges.length; i++) {\n        const edge = node.edges[i];\n        if (entry.edgeMap[edge.id]) {\n          edge.target = entry.edgeMap[edge.id].target || edge.target;\n          edge.source = entry.edgeMap[edge.id].source || edge.source;\n        }\n      }\n    });\n    delete collapseTracker[nodeId];\n\n    this.layout = await this.adapter.run(this.layout);\n    this.render();\n  }\n\n\n  /**\n   * Enlarge node\n   *\n   * @param {string} nodeId\n   */\n  async focus(nodeId) {\n    const prev = this.chart.selectAll('.node').filter(d => d.focused === true);\n    if (prev.size() === 1) {\n      const datum = prev.datum();\n      delete datum.width;\n      delete datum.height;\n      delete datum.focused;\n    }\n\n    const node = this.chart.selectAll('.node').filter(d => d.id === nodeId);\n\n    // Don't enlarge compound nodes\n    if (node.nodes && node.nodes.length > 0) return;\n\n    node.datum().width = 400;\n    node.datum().height = 300;\n    node.datum().focused = true;\n\n    this.layout = await this.adapter.run(this.layout);\n    this.render();\n  }\n\n  async unfocus(nodeId) {\n    const node = this.chart.selectAll('.node').filter(d => d.id === nodeId);\n    const datum = node.datum();\n    delete datum.width;\n    delete datum.height;\n    delete datum.focused;\n    this.layout = await this.adapter.run(this.layout);\n    this.render();\n  }\n\n\n  /**\n   * Group nodes, must be at the same level (all nodes must share the same parent)\n   *\n   * @param {string} groupName\n   * @param {array} nodeIds - node identifiers\n   */\n  async group(groupName, nodeIds) {\n    const chart = this.chart;\n\n    // 0) check parent\n    const nodesData = chart.selectAll('.node').filter(d => nodeIds.includes(d.id)).data();\n    if (_.uniq(nodesData.map(d => d.parent.id)).length !== 1) {\n      console.log('Cannot group across different levels');\n      return;\n    }\n\n    const groupNode = {\n      id: groupName,\n      label: groupName,\n      concept: groupName,\n      depth: nodesData[0].depth,\n      type: 'custom',\n      parent: nodesData[0].parent,\n      nodes: [],\n      data: { label: groupName }\n    };\n\n    // 1) Move nodes to new group\n    const parentData = nodesData[0].parent;\n    nodeIds.forEach(nodeId => {\n      const temp = _.remove(parentData.nodes, node => node.id === nodeId)[0];\n\n      // Need to create a new node wrapper to avoid double pointers problem\n      const newNode = { ...temp };\n      newNode.parent = groupNode;\n      groupNode.nodes.push(newNode);\n    });\n\n    // 2) Add new gruop node\n    parentData.nodes.push(groupNode);\n\n    this.layout = await this.adapter.run(this.layout);\n    this.render();\n  }\n\n  /**\n   * Ungroup\n   * @param {string} groupName\n   */\n  async ungroup(groupName) {\n    const chart = this.chart;\n    const groupData = chart.selectAll('.node').filter(d => d.id === groupName).data()[0];\n    const parentData = groupData.parent;\n\n    // 0) Remove group\n    _.remove(parentData.nodes, n => n.id === groupName);\n\n    // 1) Add group children back into group parent\n    groupData.nodes.forEach(node => {\n      const temp = { ...node };\n      temp.parent = parentData;\n      parentData.nodes.push(temp);\n    });\n    delete groupData.nodes;\n\n    this.layout = await this.adapter.run(this.layout);\n    this.render();\n  }\n\n\n  // See https://github.com/d3/d3-zoom#zoomTransform\n  boundary() {\n    const chart = this.chart;\n    const t = d3.zoomTransform(chart.node());\n    const x1 = (0 - t.x) / t.k;\n    const y1 = (0 - t.y) / t.k;\n    const x2 = (this.layout.width - t.x) / t.k;\n    const y2 = (this.layout.height - t.y) / t.k;\n\n    // const x1 = 0 * t.k + t.x;\n    // const y1 = 0 * t.k + t.y;\n    // const x2 = this.layout.width * t.k + t.x;\n    // const y2 = this.layout.height * t.k + t.y;\n    return { x1, y1, x2, y2 };\n  }\n\n\n  cullEdges() {\n    const { x1, y1, x2, y2 } = this.boundary();\n\n    // Temporarily hide edges\n    this.chart.selectAll('.edge').each(function(d) {\n      const source = _.first(d.points);\n      const target = _.last(d.points);\n\n      if ((source.x < x1 || source.x > x2 || source.y < y1 || source.y > y2) &&\n          (target.x < x1 || target.x > x2 || target.y < y1 || target.y > y2)) {\n        d3.select(this).style('opacity', 0);\n      }\n    });\n  }\n\n  uncullEdges() {\n    d3.selectAll('.edge').style('opacity', 1);\n  }\n\n\n  /**\n   * Prepare the SVG and returns a chart refrence. This function will create three \"layers\": background,\n   * data, and foreground layers. The data-layer corresponds to the chart.\n   */\n  _createChart() {\n    const { width, height } = this.chartSize;\n    const viewPort = {\n      x1: 0,\n      y1: 0,\n      x2: this.layout.width,\n      y2: this.layout.height\n    };\n    const svg = d3.select(this.svgEl);\n    svg.selectAll('*').remove();\n\n    const treatedSVG = svgUtil.createChart(svg, width, height, ensureViewportSize(viewPort, this.chartSize));\n\n    // change to xMinyMin\n    treatedSVG.attr('preserveAspectRatio', 'xMidYMid meet');\n\n    // Add a debugging/background layer\n    treatedSVG.append('g').classed('background-layer', true);\n\n    // Add chart group\n    const chart = treatedSVG.append('g').classed('data-layer', true);\n\n    // Add a foreground layer\n    treatedSVG.append('g').classed('foreground-layer', true);\n\n    const _this = this;\n    function zoomed() {\n      chart.attr('transform', d3.event.transform);\n      if (_this.options.useDebugger) {\n        _this.renderDebug();\n      }\n    }\n\n    const maxZoom = Math.max(2, Math.floor(this.layout.width / this.chartSize.width));\n    this.zoom = d3.zoom().scaleExtent([0.5, maxZoom]).on('zoom', zoomed);\n    svg.call(this.zoom).on('dblclick.zoom', null);\n    return chart;\n  }\n\n  /**\n   * Standard interaction hooks, these are essentially callback functions\n   * that takes in two parameters: A d3 selection of the element, and a\n   * reference to the renderer.\n   */\n  _enableInteraction() {\n    const chart = this.chart;\n    const self = this;\n    const registry = this.registry;\n    const svg = d3.select(this.svgEl);\n    const nodes = chart.selectAll('.node');\n    const edges = chart.selectAll('.edge');\n\n    self.clickTimer = null;\n\n    const registered = (eventName) => {\n      return ({}.hasOwnProperty.call(registry, eventName));\n    };\n\n    svg.on('click', function () {\n      d3.event.stopPropagation();\n      const pointerCoords = d3.zoomTransform(svg.node()).invert(d3.mouse(this));\n      if (registered('backgroundClick')) {\n        registry.backgroundClick(d3.select(this), self, {\n          x: pointerCoords[0],\n          y: pointerCoords[1]\n        });\n      }\n    });\n\n    svg.on('dblclick', function () {\n      d3.event.stopPropagation();\n      const pointerCoords = d3.zoomTransform(svg.node()).invert(d3.mouse(this));\n      if (registered('backgroundDblClick')) {\n        registry.backgroundDblClick(d3.select(this), self, {\n          x: pointerCoords[0],\n          y: pointerCoords[1]\n        });\n      }\n    });\n\n    nodes.on('dblclick', function() {\n      d3.event.stopPropagation();\n      if (registered('nodeDblClick')) {\n        window.clearTimeout(self.clickTimer);\n        registry.nodeDblClick(d3.select(this), self);\n      }\n    });\n\n    nodes.on('click', function() {\n      d3.event.stopPropagation();\n      if (registered('nodeClick')) {\n        const _this = this;\n        window.clearTimeout(self.clickTimer);\n        self.clickTimer = window.setTimeout(() => {\n          registry.nodeClick(d3.select(_this), self);\n        }, 200);\n      }\n    });\n\n    nodes.on('mouseenter', function() {\n      d3.event.stopPropagation();\n      if (registered('nodeMouseEnter')) {\n        registry.nodeMouseEnter(d3.select(this), self);\n      }\n    });\n\n    nodes.on('mouseleave', function() {\n      d3.event.stopPropagation();\n      if (registered('nodeMouseLeave')) {\n        registry.nodeMouseLeave(d3.select(this), self);\n      }\n    });\n\n    edges.on('click', function() {\n      d3.event.stopPropagation();\n      if (registered('edgeClick')) {\n        registry.edgeClick(d3.select(this), self);\n      }\n    });\n\n    edges.on('mouseenter', function() {\n      d3.event.stopPropagation();\n      if (registered('edgeMouseEnter')) {\n        registry.edgeMouseEnter(d3.select(this), self);\n      }\n    });\n\n    edges.on('mouseleave', function() {\n      d3.event.stopPropagation();\n      if (registered('edgeMouseLeave')) {\n        registry.edgeMouseLeave(d3.select(this), self);\n      }\n    });\n  }\n\n  /**\n   * Enable node dragging, this will recalculate edge end points as well\n   */\n  _enableDrag() {\n    const chart = this.chart;\n    const options = this.options;\n    const data = flatten(this.layout);\n    const nodes = chart.selectAll('.node');\n    const self = this;\n\n    function updateEdges() {\n      chart.selectAll('.edge').selectAll('path').attr('d', d => {\n        return pathFn(d.points);\n      });\n      if (options.useEdgeControl) {\n        chart.selectAll('.edge').each(function() {\n          const pathNode = d3.select(this).select('path').node();\n          const controlPoint = self.calculateEdgeControlPlacement(pathNode);\n          d3.select(this).select('.edge-control')\n            .attr('transform', svgUtil.translate(controlPoint.x, controlPoint.y));\n        });\n      }\n    }\n\n    function dragStart() {\n      d3.event.sourceEvent.stopPropagation();\n    }\n\n    function dragMove() {\n      const node = d3.select(this);\n      const draggedIds = [node.datum().id, ...node.selectAll('.node').data().map(d => d.id)];\n\n      // Check if there is a parent container\n      const parentData = d3.select(this.parentNode).datum();\n\n      // Adjust node\n      const dx = d3.event.dx;\n      const dy = d3.event.dy;\n\n      // Short circuit\n      if (parentData) {\n        if (node.datum().x + node.datum().width + dx > (parentData.width) || node.datum().x + dx < 0) {\n          return;\n        }\n        if (node.datum().y + node.datum().height + dy > (parentData.height) || node.datum().y + dy < 0) {\n          return;\n        }\n      }\n\n      node.datum().x += dx;\n      node.datum().y += dy;\n      node.attr('transform', svgUtil.translate(node.datum().x, node.datum().y));\n      // Adjust edge\n      data.edges.forEach(edge => {\n        const source = edge.source;\n        const target = edge.target;\n\n        // FIXME: ids might not work once the graph is actually database driven.\n        if (draggedIds.includes(source) && draggedIds.includes(target)) {\n          edge.points.forEach(p => {\n            p.x += dx;\n            p.y += dy;\n          });\n        } else if (draggedIds.includes(source)) {\n          edge.points[0].x += dx;\n          edge.points[0].y += dy;\n        } else if (draggedIds.includes(target)) {\n          edge.points[edge.points.length - 1].x += dx;\n          edge.points[edge.points.length - 1].y += dy;\n        }\n      });\n\n      // update edges based on new source/target coords\n      updateEdges();\n    }\n\n    function dragEnd() {\n    }\n\n    // FIXME: Need to disable current listeners first before assigning new ones?\n    const nodeDrag = d3.drag()\n      .on('start', dragStart)\n      .on('end', dragEnd)\n      .on('drag', dragMove);\n    nodes.call(nodeDrag);\n  }\n\n  /**\n   * Given a node identifier, trace up the ancestor chain and record edges along the way\n   *\n   * @param {string} id - node identifier\n   */\n  _trace(nodeId) {\n    const checked = {};\n    const data = this.layout || { edges: [] };\n    const tracedEdges = [];\n\n    function backtrack(id) {\n      if ({}.hasOwnProperty.call(checked, id)) return;\n      checked[id] = 1;\n\n      const edges = data.edges.filter(edge => edge.data.target === id);\n      edges.forEach(edge => {\n        tracedEdges.push(edge);\n        backtrack(edge.data.source);\n      });\n    }\n    backtrack(nodeId, [nodeId]);\n\n    return {\n      edges: tracedEdges.map(edge => {\n        return { source: edge.data.source, target: edge.data.target };\n      }),\n      nodes: _.uniq([...tracedEdges.map(e => e.data.source), ...tracedEdges.map(e => e.data.target)])\n    };\n  }\n}\n","export const removeChildren = (parentElement) => {\n  while (parentElement.firstChild) {\n    parentElement.removeChild(parentElement.firstChild);\n  }\n  return parentElement;\n};\n"],"names":["createChart","svg","w","h","viewport","attr","x1","y1","x2","y2","append","translate","x","y","line","pathFn","d3","d","MARKER_VIEWBOX","ARROW","ARROW_SHARP","registryFunctions","GraphRenderer","data","registry","name","fn","indexOf","Error","this","element","traverse","root","callBackFn","depth","nodes","i","length","flatten","edges","node","concat","svgUtil","curve","ensureViewportSize","v","chartSize","Math","max","width","height","SVGRenderer","options","renderMode","_this2","useEdgeControl","edgeControlOffsetType","edgeControlOffset","useDebugger","adapter","parentEl","svgEl","chart","layout","el","initialize","zoom","collapseTracker","hiddenEdges","clientWidth","clientHeight","document","createElementNS","parentElement","firstChild","removeChild","removeChildren","appendChild","style","userSelect","runLayout","vp","transition","call","transform","maxZoom","floor","scaleExtent","_createChart","buildDefs","renderNodes","renderEdges","renderNodesDelta","renderEdgesDelta","renderEdgeControls","_enableDrag","renderDebug","_enableInteraction","select","selectAll","remove","enter","classed","source","replace","target","allEdges","edgesGroup","id","newEdges","exit","each","state","filter","datum","renderEdgeAdded","renderEdgeUpdated","renderEdgeRemoved","_recursiveBuild","n","forEach","renderEdge","selection","childrenNodes","nodesGroup","parentNode","newNodes","g","size","duration","renderNodeAdded","renderNodeUpdated","renderNodeRemoved","s","renderNode","pathNode","pos","total","getTotalLength","offset","getPointAtLength","self","controlPoint","calculateEdgeControlPlacement","renderEdgeControl","background","halfW","halfH","gridData","info","t","text","k","toFixed","renderingGraph","makeRenderingGraph","run","color","highlightId","Date","getTime","feMerge","hNodes","includes","hEdges","_","some","edge","on","nodeId","find","isNil","globalX","globalY","temp","parent","console","log","dx","dy","scale","childrenNodeIds","map","edgeMap","collapsed","hidden","isEmpty","originalEdge","render","entry","hasOwnProperty","prev","focused","groupName","nodeIds","nodesData","uniq","groupNode","label","concept","type","parentData","newNode","push","groupData","boundary","first","points","last","viewPort","treatedSVG","_this","clickTimer","registered","eventName","stopPropagation","pointerCoords","invert","backgroundClick","backgroundDblClick","window","clearTimeout","nodeDblClick","setTimeout","nodeClick","nodeMouseEnter","nodeMouseLeave","edgeClick","edgeMouseEnter","edgeMouseLeave","nodeDrag","sourceEvent","draggedIds","p","checked","tracedEdges","backtrack","e"],"mappings":"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"}